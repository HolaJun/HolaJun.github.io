<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
	<link rel="stylesheet" href="/assets/css/atom-one-light.css">
    
        <title>기본CS정리</title>
		<link rel="stylesheet" type="text/css" href="/assets/css/002.css">
    
	<link rel="stylesheet" href="/assets/css/font-awesome.min.css">
	<link rel="shortcut icon" href="/assets/img/favicon.ico" type="image/x-icon">
	<link rel="icon" href="/assets/img/favicon.ico" type="image/x-icon">
	<script src="/assets/js/highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
	<div class="wrapper">

		<!-- Title -->
		<div class="default_title">
			<img src="/assets/img/mycomputer.png" />
			
				<h1>HolaJun</h1>
			
		</div>

		<!-- Menubar -->
		<ul class="topbar">
	<a href="/" target="_self"><li><u>H</u>ome</li></a>
	<a href="http://github.com/holajun" target="_blank"><li><u>G</u>ithub</li></a>
	<a href="/me"><li><u>K</u>akao</li></a>
	<a href="/me"><li><u>A</u>boutMe</li></a>
</ul>


		<!-- Tag_List -->
		<div class="tag_list">
			<ul id="tag-list">
				<li><a href="/" ><img src="/assets/img/disk.png" />(C:)</a>
			<ul>
				
				
				<li>
					<a href="/tag/test/" title="test">
						<img src="/assets/img/folder.ico" />
						<!-- 태그이름 -->
						test
					</a>
				</li>
				
				<li>
					<a href="/tag/기본/" title="기본">
						<img src="/assets/img/folder.ico" />
						<!-- 태그이름 -->
						기본
					</a>
				</li>
				
			</ul>
				</li>
			</ul>
		</div>

		<!-- Post_List -->
		<div class="post_list">
			
				<ul>
					
					<li><a href="/2018-09-07/Test.MARKUP" title="Test.markup"><img src="/assets/img/file.ico" title="Test.markup" />Test.markup</a></li>
					
					<li><a href="/2018-08-23/%EA%B8%B0%EB%B3%B8CS%EC%A0%95%EB%A6%AC" title="기본CS정리"><img src="/assets/img/file.ico" title="기본CS정리" />기본CS정리</a></li>
					
					<li><a href="/2018-08-05/Ubuntu-nodejs-install" title="Ubuntu Nodejs설치"><img src="/assets/img/file.ico" title="Ubuntu Nodejs설치" />Ubuntu Nodejs설치</a></li>
					
				</ul>
			
		</div>
		<div class="post_total">
			
				<div class="left">3 object(s)</div>
			
			<div class="right">&nbsp;</div>
		</div>
	</div>

	<!-- 글이 클릭된 상태인 경우 -->
	
        <div class="content">
			<div class="post_title">
				<img src="/assets/img/file.png" />
				<h1>기본CS정리</h1>
				<a href="/"><div class="btn"><span class="fa fa-times"></span></div></a> <!-- 최소화 -->
				<div class="btn btn_max"><span class="fa fa-window-maximize"></span></div> <!-- 최대화 -->
				<div class="btn"><span class="fa fa-window-minimize"></span></div> <!-- 종료 -->
			</div>
			<ul class="topbar">
				<li>August 23, 2018</li>
			</ul>
			<div class="post_content">
        		<h2 id="추상화">추상화</h2>

<pre><code>Application: AAABAABCAACC

---------------------------------------
layer A'': AAAB, AABC, AACC, ...
---------------------------------------
layer A': AA, AB, BC, CC, ...
---------------------------------------
layer A : A, B, C
---------------------------------------

</code></pre>

<p>추상화 : 중복을 없애고 복잡한 것을 단순하게 표현하는 것</p>

<p>핵심: ‘부품의 재사용’, ‘계층의 분리/분업’</p>

<h1 id="컴퓨터-구조와-파일">컴퓨터 구조와 파일</h1>

<h3 id="컴퓨터-구조">컴퓨터 구조</h3>

<ul>
  <li>
    <p>CPU(Central Processing Unit) : 메모리(주기억장치)의 명령어(더하기, 빼기, 읽기, 쓰기)들을 읽어 순차적으로</p>

    <p>처리. 이 때의 명령은 단순 산술 계산부터, 메모리나 주변 장치(보조기억장치, 프린터, 키보드, 디스플레이 등)</p>

    <p>와의 입출력(IO) 제어.</p>
  </li>
  <li>CPU와 메모리 자체로도 하나의 컴퓨터라 칭할 수 있음.</li>
  <li>
    <p>CPU: 계산 능력을 가진 사람
메모리: 사람 앞의 책상(작업 공간)
보조기억장치: 책(데이터)을 보관할 수 있는 책장(하드디스크)</p>
  </li>
  <li>RAM(Random Accecc Memory): 휘발성(전원이 꺼지면 데이터 날아감) 메모리.</li>
  <li>ROM(Read Only Memory): BIOS 내용이 영구적으로 기록되어 있음</li>
</ul>

<h3 id="cpu와-메모리">CPU와 메모리</h3>

<blockquote>
  <p>CPU와 메모리는 대화한다! 프로세스(실행중인 프로그램)는 메모리 안에 존재함.</p>
</blockquote>

<ul>
  <li>
    <p>32bit vs 64bit</p>

    <ul>
      <li>
        <p><strong>32bit: 0000 0000 0000 0000 0000 0000 0000 0000</strong></p>
      </li>
      <li>
        <p>CPU가 처리할 수 있는 명령어의 크기, CPU가 가리킬 수 있는 메모리의 번지수, 메모리 데이터 블록의 크</p>

        <p>기 등이 32bit로 고정되어 있음.</p>
      </li>
      <li>
        <p>메모리 번지수의 최대: 1111 1111 1111 1111 1111 1111 1111 1111 =&gt; 2^32 =&gt; 대략 43억</p>

        <p>0번지부터 대략 40억번지(0 ~ 4GB)까지 표현 가능.</p>

        <p>그러므로, 32bit CPU에서는 메모리(RAM) 용량이 4GB 이상을 인식할 수 없음.</p>
      </li>
      <li>
        <p><strong>64bit: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000</strong></p>
      </li>
      <li>
        <p>2^64 bit =&gt; 약 1800경. 32bit와 비교했을 때 어마어마한 차이.</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="메모리와-보조기억장치">메모리와 보조기억장치</h3>

<ul>
  <li>프로그램 최초 실행 중 Loading이 뜨는 이유: 보조기억장치에 저장된 프로그램(데이터)을 메모리로 읽어들이는(Load) 과정 중 소요되는 시간이 필요하기 때문.</li>
  <li>보조기억장치가 필요한 이유: RAM은 휘발성 -&gt; 영구적 저장 불가. 비휘발성 저장장치 필요.</li>
</ul>

<h3 id="파일">파일</h3>

<ul>
  <li>
    <p>메모리든 보조기억장치든 저장되어있는 모든 데이터는 1010101로 반복되어있는 단순한 이진 데이터이다.</p>
  </li>
  <li>데이터를 구성하는 약속에 따라서 010101… 을 기록.
    <ul>
      <li>
        <p>숫자, 문자를 다루는 체계. 이러한 체계는 오래 전부터 이미 자리 잡혀 있음.</p>
      </li>
      <li>
        <p>소프트웨어별로 독립적으로 다루는 체계(ex. MSword는 .hwp 파일을 읽을 수 없음)</p>
      </li>
      <li>
        <p><strong>파일명이나 확장자는 파일 자체를 구분하는 역할일 뿐, 이외의 역할은 없음.</strong></p>

        <p>운영체제에서 파일을 구분하고 인식하기 위한 확장자일 뿐.</p>

        <p>*.jpg 라고 해서 무조건 이미지 파일이라고 장담할 수 없음.</p>

        <p>다만, 실제 파일 내부의 데이터가 jpg의 약속 체계를 따르는지가 중요.</p>
      </li>
      <li>
        <p>파일에 기록된 이진 데이터가 의미를 가질 때는, 관련된 소프트웨어(프로그램)이 파일을 읽고 쓸 때이다.</p>

        <p>이 때, 파일의 의미를 가지려면, 이진 데이터를 특정한 약속(=파일 포맷)에 맞춰 나열해야 함.</p>
      </li>
      <li>
        <p>대표적인 파일 포맷: 문서, 프로그램, 영상, 사운드, 이미지, 압축 프로그램 등</p>
      </li>
    </ul>
  </li>
  <li>
    <p>실행파일</p>

    <ul>
      <li>
        <p>다른 파일과 다른 특수한 파일인가? No. 실행파일 또한 101010… 으로 이루어진 단순한 파일.</p>
      </li>
      <li>
        <p>실행 파일(프로그램)을 실행하는 주체는 운영체제임. 운영체제에 종속된 파일 포맷을 따름.</p>

        <p>(윈도우에서 실행되는 실행파일은 맥에서 실행할 수 없음)</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="인코딩">인코딩</h3>

<ul>
  <li>
    <p>문자를 표현하기 위한 약속</p>
  </li>
  <li>
    <p>컴퓨터의 초창기때부터 정수와 소수 등 수의 체계를 표현하는 약속이 구현되어 있었음.</p>
  </li>
  <li>
    <p>ASCII</p>

    <ul>
      <li>
        <p>컴퓨터와 통신 장비를 비롯한 문자를 사용하는 많은 장치에 사용.</p>

        <p>대부분의 문자 인코딩이 아스키에 기초를 두고 있음.</p>
      </li>
      <li>정수와 문자(숫자, 공백 및 특수문자)를 1:1로 Mapping(ex. 65=A, 66=B …)</li>
      <li>0~127(7bit)까지 128가지의 문자열을 Mapping</li>
    </ul>
  </li>
  <li>
    <p>ANSI</p>

    <ul>
      <li>
        <p>ASCII 인코딩에서 남은 1byte를 활용해 128~255까지의 수를 다른 언어로 확장한 1Byte(8bit) 인코딩</p>

        <p>ANSI-949는 남은 128~255까지의 수를 한글에 Mapping한 인코딩</p>
      </li>
    </ul>
  </li>
  <li>
    <p>Unicode</p>

    <ul>
      <li>전세계의 모든 문자를 일관적으로 표현할 수 있게 설계된 산업표준.</li>
      <li>전세계의 문자를 효율적으로 1:1 Mapping.</li>
    </ul>
  </li>
  <li>
    <p>UTF-8</p>

    <ul>
      <li>
        <p>대부분의 웹에서 UTF-8을 씀</p>
      </li>
      <li>
        <p>전 세계의 문자를 1~4byte의 가변 길이로 표현.</p>
      </li>
      <li>
        <p>ASCII와 호환 가능</p>
      </li>
      <li>
        <p>웹 및 다양한 산업에서의 대표주자</p>
      </li>
      <li>
        <p>특히 UTF-8에서 한글이 깨지는 경우는, 저장할 때(서버에서 전송해주는 웹페이지)와 인코딩을 읽을 때(브</p>

        <p>라우저에서 다운 받은 웹페이지를 해석할 때)의 인코딩이 서로 일치하지 않기 때문.</p>

        <p>서로 다른 약속 체계로 소통하려니 문제가 생김.</p>
      </li>
    </ul>
  </li>
</ul>

<h1 id="프로그램과-프로세스">프로그램과 프로세스</h1>

<h3 id="운영체제">운영체제</h3>

<p><img src="https://images.weserv.nl/?url=ssl%3Aimages.weserv.nl%2F%3Furl%3Dstatic.codeflow.study%252F1522956625218_Screen-Shot-20180406-at-4.30.05-AM.png%26crop%3D962%2C499%2C7%2C28%26q%3D100%26errorredirect%3Dssl%253Acodeflow.study%252Fimage-not-found.png&amp;w=640&amp;h=640&amp;q=100&amp;errorredirect=ssl%3Acodeflow.study%2Fimage-not-found.png" alt="ë¦¬ëì¤ ì´ìì²´ì ì ë¶í ê³¼ì " /></p>

<ul>
  <li>
    <p>부팅시 실행되는 하나의 (시스템)프로그램</p>
  </li>
  <li>
    <p>주변기기들을 상호 연결하고 제어</p>
  </li>
  <li>
    <p>응용프로그램이 사용할 수 있는 서비스 및 라이브러리를 제공</p>

    <ul>
      <li>
        <p>컴퓨터의 메인보드에 접속된 하드웨어들을 상호 연결하고 제어함</p>
      </li>
      <li>
        <p>응용프로그램이 사용 할 수 있는 서비스/라이브러리들을 제공</p>
      </li>
      <li>
        <p>보조 기억장치 및 주변기기를 추상화한 파일시스템을 조작 할 수 있도록 응용프로그램에 API를 제공</p>
      </li>
      <li>
        <p>네트워킹을 추상화하여 응용프로그램에 API를 제공</p>
      </li>
      <li>
        <p>공통적인 GUI를 쉽게 만들 수 있게 추상화하여 응용프로그램에 API를 제공</p>
      </li>
      <li>
        <p>응용프로그램의 실행, 멀티태스킹을 위한 스케쥴링</p>
      </li>
      <li>
        <p>컴퓨터의 보안과 사용자 계정을 관리</p>
      </li>
    </ul>
  </li>
  <li>
    <p>응용프로그램의 실행</p>

    <ul>
      <li>
        <p>exploer.exe, Finder…</p>
      </li>
      <li>
        <p>멀티태스킹을 위한 스케줄링</p>

        <p><strong>★  프로그램은 운영체제에 종속적이다.</strong></p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="apiapplication-programming-interface">API(Application Programming Interface)</h3>

<ul>
  <li>
    <p>응용 프로그램 프로그래밍 인터페이스. 응용 프로그램에서 사용할 수 있도록, 운영체제나 프로그래밍</p>

    <p>언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스(사물간 또는 사물과 인간간의 의사소통이 가</p>

    <p>능하도록 일시적 혹은 영속적인 접근을 목적으로 만들어진 물리적, 가성적 매개체)</p>
  </li>
  <li>
    <p>운영체제가 개발자들을 위해 미리 높은 추상화 수준으로 준비해놓은 코드의 집합.</p>
  </li>
</ul>

<blockquote>
  <p>” 네가 프로그램을 만들 때 무슨무슨 기능을 쓸 수 있게 미리 코드(API)를 준비를 해뒀어!</p>

  <p>이러이러한 방식대로만 코드를 작성하면 되니까 설명서 잘 읽고 잘 써먹어! “</p>
</blockquote>

<h3 id="프로그램">프로그램</h3>

<p><img src="https://images.weserv.nl/?url=static.codeflow.study%2F1522956178388_languages.jpg&amp;w=440&amp;h=440&amp;q=100&amp;errorredirect=ssl%3Acodeflow.study%2Fimage-not-found.png" alt="ê¸°ê³ì´ìì ê³ ìì¤ ì¸ì´ê¹ì§" /></p>

<p><img src="https://images.weserv.nl/?url=static.codeflow.study%2F1522956075190_ext2machinecode.png&amp;w=640&amp;h=640&amp;q=100&amp;errorredirect=ssl%3Acodeflow.study%2Fimage-not-found.png" alt="ì´ìë¸ë¦¬ì ê¸°ê³ì´(CPU ì¸ì¤í¸ë­ì ì¤í¸ë¦¼)" /></p>

<ul>
  <li>
    <p><strong>기계어(명령어, Instruction)</strong></p>

    <ul>
      <li>0x000000FF는 더하기!</li>
      <li>0x000000FE는 빼기!</li>
    </ul>
  </li>
  <li>
    <p><strong>CPU 아키텍쳐(명령어 집합, Instruction Set):</strong> 기계어와 하드웨어 기능을 Mapping한 것.</p>
  </li>
  <li>
    <p><strong>어셈블리어</strong></p>

    <ul>
      <li>
        <p>add(더하기)는 0x000000FF</p>
      </li>
      <li>
        <p>sub(빼기)는 0x000000FE</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>프로그래밍 언어</strong></p>

    <ul>
      <li>
        <p>x+y 라는 프로그래밍 코드는 어셈블리어로 add x y 라고 표현 가능</p>
      </li>
      <li>
        <p>프로그래밍 언어로 작성된 소스코드는 <strong>단순한 텍스트 파일</strong></p>
      </li>
      <li>
        <p>텍스트파일 =&gt; 어셈블리어 =&gt; 기계어의 번역을 통해 소스코드를 CPU가 실행가능한 포맷으로 만</p>

        <p>드는 과정을 컴파일이라 칭함. 번역해주는 프로그램은 <strong>컴파일러.</strong></p>
      </li>
      <li>
        <p>번역된 파일을 <strong>실행파일(프로그램)</strong>이라고 함</p>
      </li>
      <li>
        <p>컴파일된 프로그램은 운영체제와 CPU아키텍쳐에 종속적.</p>
      </li>
      <li>
        <p>소스코드</p>

        <ul>
          <li>사람이 이해하기 쉬운 프로그래밍 언어로 프로그램의 작동을 묘사한 텍스트 파일</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>리눅스에서 컴파일한 프로그램은 윈도우에서 실행되지 않는다.</p>
  </li>
  <li>
    <p>Intel CPU 아키텍쳐에 맞게 컴파일한 프로그램은 ARM 아키텍쳐 CPU를 쓰는 컴퓨터에서 실행되지 않거나 오작동을 함</p>
  </li>
  <li>
    <p>Intel CPU 윈도우에서 작성한 소스코드(텍스트파일)을 복사해서 ARM 윈도우에서 컴파일을 할 수 있을까? <strong>문제 없음.</strong></p>
  </li>
  <li>
    <p>Intel 리눅스에서 작성한 소스코드를 복사해서 ARM 윈도우에서 컴파일이 될까? <strong>될 수도, 안 될수도</strong></p>
  </li>
  <li>
    <p>소스코드에서 리눅스 운영체제에 종속적인 기능을 사용한다면? (GUI, API 등) <strong>사용 불가</strong></p>
  </li>
  <li>
    <p>POSIX</p>

    <ul>
      <li>이식 가능 운영체제 인터페이스의 약자.</li>
      <li>서로 다른 UNIX OS의 공통 API를 정리하여 이식성 높은 유닉스 응용 프로그램을 개발하기 위한 목적으로, IEEE가 책정한 애플리케이션 인터페이스 규격.</li>
      <li>유닉스 계열 외에 마이크로소프트 윈도 NT는 POSIX 1.0에 준하는 POSIX 서브 시탑재하고 있으며, POSIX 응용 프로그램을 서브 시스템에서 실행할 수 있다.</li>
    </ul>
  </li>
  <li>
    <p>결론</p>

    <ul>
      <li>상황에 따라 다르며, 플랫폼에 따라 차이가 날 수 있다.</li>
      <li>프로그램은 CPU 아키텍쳐와 운영체제에 종속적이다.</li>
    </ul>
  </li>
</ul>

<h3 id="메모리-구조">메모리 구조</h3>

<ul>
  <li>Text: 기계어로 표현된 프로그램의 로직들</li>
  <li>Data: 프로그램을 작성할 때 지정된 값들</li>
  <li>Heap: 런타임(Runtime)에 동적으로 생성되는 값들</li>
  <li>Stack: 함수라고 불리는 프로그램의 반복적인 로직이 실행되고 소멸되는 공간</li>
</ul>

<h1 id="guicli-shell-파일-권한">GUI/CLI, Shell, 파일 권한</h1>

<ul>
  <li>GUI(Graphical User Interface)
    <ul>
      <li>웹브라우저, 에디엍, 게임, 대부분의 엔드유저용 응용프로그램, 스마트폰 앱 등</li>
      <li>응용프로그램들은 운영체제별로 비슷한 GUI를 가짐(OS가 제공하는 GUI API)</li>
    </ul>
  </li>
  <li>GLI(Command Line Interface)
    <ul>
      <li>명령 줄 인터페이스(CLI) 또는 명령어 인터페이스는 텍스트 터미널을 통해 사용자와 컴퓨터가 상호작용하는 방식</li>
      <li>작업 명령은 사용자가 컴퓨터 키보드 등을 통해 문자열의 형태로 입력하며, 컴퓨터로부터의 출력 역시 문자열의 형태로 주어진다</li>
    </ul>
  </li>
  <li>왜 CLI를 선호할까?
    <ul>
      <li>개발자용 프로그램, 내부적인 시스템 프로그램 등은 대부분이 CLI 프로그램이다.</li>
      <li>가볍고 빠르며 텍스트만으로 입출력하기에 원격으로 조작하기 용이하다</li>
      <li>CLI와 GUI의 차이는 단순한 User Interface의 차이일 뿐. 본질적으로는 큰 차이가 없는 프로그램들이다.</li>
    </ul>
  </li>
  <li>Shell
    <ul>
      <li>운영체제의 기능을 이용하고 <strong>프로그램을 실행하기 위한 프로그램</strong></li>
      <li>운영체제의 Knernel(알맹이)과 유저를 이어주는 Shell(껍데기)</li>
      <li>GUI Shell(explorer, 탐색기 등), CUI Shell(cmd, terminal)</li>
    </ul>
  </li>
</ul>

<h3 id="개발자라면-왜-linux를-사용해야-하는가">개발자라면 왜 Linux를 사용해야 하는가?</h3>

<ul>
  <li>튼튼하고 신뢰성 있는 무료 운영체제</li>
  <li>다양한 플랫폼에 이식성</li>
  <li>네트워킹에서 뛰어난 성능</li>
  <li>Opensource</li>
  <li>거대한 생태계를 가지고 있음. 개발자들의 요람</li>
</ul>

<h1 id="네트워크">네트워크</h1>

<h3 id="네트워크의-구분">네트워크의 구분</h3>

<ul>
  <li>LAN(Local Area Network): 집, 회사, 지역 등의 지엽적인 네트워크를 지칭</li>
  <li>WAN(Wide Area Network): LAN보다 큰 규모로 국가, 대륙을 아우르는 원거리 망을 지칭</li>
  <li>인트라넷(Intranet): 집, 회사 등 폐쇄적으로 운영되는 네트워크</li>
  <li>인터넷(Internet): 전세계에서 접근이 가능한 공개적인 네트워크</li>
</ul>

<h3 id="통신의-원리">통신의 원리</h3>

<ul>
  <li>
    <p>통신은 호스트 간에 이루어진다? 편지(데이터)를 건물(ip주소)간에 주고 받는다?</p>

    <p>정확히 말하자면,</p>

    <p><strong>통신은 호스트(건물)의 프로세스(건물에 거주하는 사람)간 이루어진다!</strong></p>

    <p><strong>(편지(데이터)는 사람(포트번호)간에 주고 받는다!)</strong></p>
  </li>
  <li>
    <p>프로세스</p>

    <ul>
      <li>호스트상에서 프로세스를 구분하기 위한 표식 =&gt;  <strong>[포트 번호]</strong></li>
    </ul>
  </li>
  <li>
    <p>호스트</p>

    <ul>
      <li>네트워크 안에서 호스트를 구분하기 위한 표식 =&gt;  <strong>[아이피 주소]</strong></li>
    </ul>
  </li>
  <li>
    <p>네트워크 장치, 이더넷, 와이파이, 블루투스 등의 NIC(Network Interface Controller)</p>

    <ul>
      <li>네트워크 안에서 장치를 구분하기 위한 표식 =&gt;  <strong>[MAC 주소]</strong></li>
    </ul>
  </li>
</ul>

<pre><code>Q. 맥주소를 두고 아이피가 필요한 이유는?
A. IP는 라우팅에 의해 적합하게 설계된 주소체계(지번 주소, 도로명 주소처럼)
   프로세스 → OS → 네트워크장치 → LAN/WAN → 라우터 → 라우터 → 라우터 ··· 
   → 어딘가의 호스트 → 어딘가의 프로세스
</code></pre>

<h3 id="포트-번호port-number">포트 번호(Port Number)</h3>

<ul>
  <li>48bit(약 280조의 경우의 수) MAC Address → <strong>장치 식별자</strong>
    <ul>
      <li>장치에 고정되어 있는 식별자</li>
    </ul>
  </li>
  <li>32bit/128bit의 IP Address → <strong>호스트 식별자</strong>
    <ul>
      <li>운영체제에 할당되는 가상적인, 호스트를 식별하기 위한 식별자</li>
    </ul>
  </li>
  <li>16bit의 Port Number → <strong>프로세스 식별자</strong>
    <ul>
      <li>2^16, 65536개 숫자</li>
      <li>이 중의 하나의 숫자를 운영체제로부터 할당</li>
      <li>0~1023 대역의 포트번호를 할당하려면 관리자 권한 필요</li>
      <li>예시) 
클라이언트1 카카오톡 x.x.x:1234 ————— 카카오톡 서버 a.b.c:3000
클라이언트2 카카오톡 y.y.y:2111 ————— 카카오톡 서버 a.b.c:3000
클라이언트3 카카오톡 z.z.z:2333 —————- 카카오톡 웹서버 a.b.c:80
클라이언트3 브라우저 z.z.z:2233 —————- 카카오톡 웹서버 a.b.c:80</li>
    </ul>
  </li>
  <li>각 다른 서버의 포트는 같을 수 없다.</li>
  <li>서버측의 포트 번호는 고정이어야 클라이언트에서 연결을 할 수 있음.
(보통 1024 아래의 낮은 대역으로 고정)</li>
  <li>클라이언트측의 포트 번호는 (기본적으로) 랜덤.
(보통 높은 대역의 포트 번호를 씀)</li>
</ul>

<h3 id="ipinternet-protocol">IP(Internet Protocol)</h3>

<ul>
  <li>32bit(2^32, 약 43억개)로 설계된 IP주소 체계</li>
  <li>10101100 0001110 00000001 00000001
 → 172.30.1.1</li>
  <li>IP의 고갈 → 128bit의 IPv6로 호환성을 유지하면서 전환 중.</li>
</ul>

<h3 id="공인망과-사설망">공인망과 사설망</h3>

<ul>
  <li>
    <p>기본적으로 공인 Public IP였으나 사설 Private IP 대역의 도입</p>
  </li>
  <li>
    <p>10.0.0.0 ~ 10.255.255.255
172.16.0.0 ~ 172.31.255.255
192.168.0.0 ~ 192.168.255.255
이 IP는 본인 마음대로 써도 된다. 사설망 안에서만.</p>
  </li>
  <li>
    <p>ex. 현재 사무실의 IP 목록</p>

    <ul>
      <li>172.30.1.1 스마트폰</li>
      <li>172.30.1.2 노트북</li>
      <li>172.30.1.3 데스크탑</li>
      <li>172.30.1.4 스마트TV</li>
      <li>172.30.1.254 공유기</li>
    </ul>

    <p>​    → 사설망 IP가 5개</p>
  </li>
  <li>
    <p>NAT(Network Address Translation)</p>

    <ul>
      <li>네트워크 주소 변환</li>
      <li>사설IP와 공인IP를 Mapping시켜주는 기법</li>
    </ul>
  </li>
  <li>
    <p>게이트웨이/공유기는 자신의 Public IP를 통해서 뒷단의 노드들을 대표해 인터넷에 연결</p>
  </li>
</ul>

<h3 id="osi-7-layer">OSI 7 Layer</h3>

<p><img src="https://images.weserv.nl/?url=static.codeflow.study%2F1523025418664_net2.jpg&amp;w=640&amp;h=640&amp;q=100&amp;errorredirect=ssl%3Acodeflow.study%2Fimage-not-found.png" alt="Frame/Packet Header" /></p>

<ul>
  <li>Message
    <ul>
      <li>프로세스가 전당하고자 하는 데이터</li>
    </ul>
  </li>
  <li>Segment/Datagram
    <ul>
      <li>보내는/받는 프로세스를 식별하기 위해 부가 데이터(Port) 추가</li>
    </ul>
  </li>
  <li>Packet
    <ul>
      <li>보내는/받는 호스트를 식별하기 위해 부가 데이터(IP)를 추가</li>
    </ul>
  </li>
  <li>Frame
    <ul>
      <li>실제로 데이터를 보내는/받는 장치인 유선랜(Ethernet) 카드, Wifi 및 Bluetooth카드 등의 장치를 식별하기 위해 부가 데이터(Mac Address) 추가</li>
    </ul>
  </li>
</ul>

<h3 id="tcpudp">TCP/UDP</h3>

<ul>
  <li>
    <p>송신자 MAC address, IP, Port</p>

    <pre><code>  수신자 MAC address, IP, Port

  데이터
</code></pre>
  </li>
  <li>TCP
    <ul>
      <li>신뢰성 프로토콜</li>
      <li>부가적인 데이터와 제어를 통해
        <ul>
          <li>데이터의 수신 순서 보장</li>
          <li>데이터의 수신 성공 보장</li>
          <li>안전성과 신뢰성이 필요한 대부분의 응용프로그램, 메일, 메신저, 인터넷, 게임 등에 사용됨</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>UDP
    <ul>
      <li>데이터를 그냥 보냄. 비신뢰성 프로토콜</li>
      <li>데이터 누락, 중복, 순서 바뀜 등이 일어날 수 있음.</li>
      <li>게임, VoIP, IPTV, 영상 스트리밍 등</li>
    </ul>
  </li>
</ul>

<h3 id="프로토콜protocol">프로토콜(Protocol)</h3>

<ul>
  <li>
    <p>통신규약</p>
  </li>
  <li>
    <p>저수준(Low-Level) 프로토콜</p>

    <ul>
      <li>IP, TCP/UDP</li>
    </ul>
  </li>
  <li>
    <p>응용 프로토콜</p>

    <ul>
      <li>
        <p>원격으로 집안의 전등을 켜고 끄는 서버와, 스마트폰 클라리언트 앱의 통신규약을 만든다고 가정.</p>

        <p>1번 전등을 켠다 ==&gt; 11 ==&gt; 성공시 1</p>

        <p>1번 전등을 끈다 ==&gt; 10 ==&gt; 실패시 0</p>

        <p>2번 전등을 켠다 ==&gt; 21</p>

        <p>2번 전등을 끈다 ==&gt; 20</p>
      </li>
    </ul>
  </li>
  <li>
    <p>Well Known Port</p>

    <ul>
      <li>오래 전부터 약속된 표준 프로토콜.</li>
      <li>HTTP   80  웹 문서 전송</li>
      <li>FTP      21  파일 전송</li>
      <li>SSH     22  원격 셸</li>
      <li>DNS     53  도메인 네임 서버</li>
      <li>POP3, SMTP, HTTPS, etc …</li>
    </ul>
  </li>
</ul>

<h3 id="서비스-네트워킹-형태">서비스 네트워킹 형태</h3>

<ul>
  <li>서버/클라이언트
    <ul>
      <li>서버는 다수의 클라이언트의 요청을 처리</li>
      <li>2개의 프로그램 필요</li>
      <li>클라이언트는 서버에 요청을 하고 응답을 받음</li>
      <li>온라인 게임, 웹 서비스, 페이스북 앱, 카카오톡 앱, 음악/영상 스트리밍, 원격 셸(SSH) 등</li>
    </ul>
  </li>
  <li>P2P (Peer to Peer)
    <ul>
      <li>각 클라이언트들이 서버이자 클라이언트의 역할을 담당</li>
      <li>한개의 프로그램이 필요</li>
      <li>토렌트, 1:1온라인 게임 등 서버/클라이언트 구분 없이 연결된 프로세스들이 동등한 작업을 함</li>
    </ul>
  </li>
</ul>

				
					<br>
<hr>
<br>
<div class="donate">
 donate.html
</div>

				
			</div>
		</div>
    
	<script src="/assets/js/001.js"></script>
	<script src="/assets/js/002.js"></script>
	<div class="footer">
		<p>All Copyright Holajun. This Template by <a href="http://github.com/h01000110" target="_blank">h01000110. Thank you! </a></p>
	</div>
</body>
</html>
