## 추상화

```
Application: AAABAABCAACC

---------------------------------------
layer A'': AAAB, AABC, AACC, ...
---------------------------------------
layer A': AA, AB, BC, CC, ...
---------------------------------------
layer A : A, B, C
---------------------------------------

```

추상화 : 중복을 없애고 복잡한 것을 단순하게 표현하는 것

핵심: '부품의 재사용', '계층의 분리/분업'



## 컴퓨터 구조와 파일

### 컴퓨터 구조

- CPU(Central Processing Unit) : 메모리(주기억장치)의 명령어(더하기, 빼기, 읽기, 쓰기)들을 읽어 순차적으로 

  처리. 이 때의 명령은 단순 산술 계산부터, 메모리나 주변 장치(보조기억장치, 프린터, 키보드, 디스플레이 등)

  와의 입출력(IO) 제어.
- CPU와 메모리 자체로도 하나의 컴퓨터라 칭할 수 있음.
- CPU: 계산 능력을 가진 사람
  메모리: 사람 앞의 책상(작업 공간)
  보조기억장치: 책(데이터)을 보관할 수 있는 책장(하드디스크)

- RAM(Random Accecc Memory): 휘발성(전원이 꺼지면 데이터 날아감) 메모리.
- ROM(Read Only Memory): BIOS 내용이 영구적으로 기록되어 있음



### CPU와 메모리

> CPU와 메모리는 대화한다! 프로세스(실행중인 프로그램)는 메모리 안에 존재함.

- 32bit vs 64bit

  - **32bit: 0000 0000 0000 0000 0000 0000 0000 0000**

  - CPU가 처리할 수 있는 명령어의 크기, CPU가 가리킬 수 있는 메모리의 번지수, 메모리 데이터 블록의 크

    기 등이 32bit로 고정되어 있음.

  - 메모리 번지수의 최대: 1111 1111 1111 1111 1111 1111 1111 1111 => 2^32 => 대략 40억

    0번지부터 대략 40억번지(0 ~ 4GB)까지 표현 가능.

    그러므로, 32bit CPU에서는 메모리(RAM) 용량이 4GB 이상을 인식할 수 없음.

  - **64bit: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000**

  - 2^64 bit => 약 1800경. 32bit와 비교했을 때 어마어마한 차이.



### 메모리와 보조기억장치

- 프로그램 최초 실행 중 Loading이 뜨는 이유: 보조기억장치에 저장된 프로그램(데이터)을 메모리로 읽어들이는(Load) 과정 중 소요되는 시간이 필요하기 때문.  
- 보조기억장치가 필요한 이유: RAM은 휘발성 -> 영구적 저장 불가. 비휘발성 저장장치 필요.



### 파일

- 메모리든 보조기억장치든 저장되어있는 모든 데이터는 1010101로 반복되어있는 단순한 이진 데이터이다. 

- 데이터를 구성하는 약속에 따라서 010101... 을 기록.
  - 숫자, 문자를 다루는 체계. 이러한 체계는 오래 전부터 이미 자리 잡혀 있음.

  - 소프트웨어별로 독립적으로 다루는 체계(ex. MSword는 .hwp 파일을 읽을 수 없음)

  - **파일명이나 확장자는 파일 자체를 구분하는 역할일 뿐, 이외의 역할은 없음.**

    운영체제에서 파일을 구분하고 인식하기 위한 확장자일 뿐.

    *.jpg 라고 해서 무조건 이미지 파일이라고 장담할 수 없음.

    다만, 실제 파일 내부의 데이터가 jpg의 약속 체계를 따르는지가 중요.

  - 파일에 기록된 이진 데이터가 의미를 가질 때는, 관련된 소프트웨어(프로그램)이 파일을 읽고 쓸 때이다.

    이 때, 파일의 의미를 가지려면, 이진 데이터를 특정한 약속(=파일 포맷)에 맞춰 나열해야 함.

  - 대표적인 파일 포맷: 문서, 프로그램, 영상, 사운드, 이미지, 압축 프로그램 등
- 실행파일

  - 다른 파일과 다른 특수한 파일인가? No. 실행파일 또한 101010... 으로 이루어진 단순한 파일.

  - 실행 파일(프로그램)을 실행하는 주체는 운영체제임. 운영체제에 종속된 파일 포맷을 따름.

    (윈도우에서 실행되는 실행파일은 맥에서 실행할 수 없음)



### 인코딩

- 문자를 표현하기 위한 약속

- 컴퓨터의 초창기때부터 정수와 소수 등 수의 체계를 표현하는 약속이 구현되어 있었음.

- ASCII

  - 컴퓨터와 통신 장비를 비롯한 문자를 사용하는 많은 장치에 사용. 

    대부분의 문자 인코딩이 아스키에 기초를 두고 있음.

  - 정수와 문자(숫자, 공백 및 특수문자)를 1:1로 Mapping(ex. 65=A, 66=B ...)
  - 0~127(7bit)까지 128가지의 문자열을 Mapping

- ANSI

  - ASCII 인코딩에서 남은 1byte를 활용해 128~255까지의 수를 다른 언어로 확장한 1Byte(8bit) 인코딩

    ANSI-949는 남은 128~255까지의 수를 한글에 Mapping한 인코딩

- Unicode

  - 전세계의 모든 문자를 일관적으로 표현할 수 있게 설계된 산업표준.
  - 전세계의 문자를 효율적으로 1:1 Mapping.

- UTF-8

  - 대부분의 웹에서 UTF-8을 씀

  - 전 세계의 문자를 1~4byte의 가변 길이로 표현.

  - ASCII와 호환 가능

  - 웹 및 다양한 산업에서의 대표주자

  - 특히 UTF-8에서 한글이 깨지는 경우는, 저장할 때(서버에서 전송해주는 웹페이지)와 인코딩을 읽을 때(브

    라우저에서 다운 받은 웹페이지를 해석할 때)의 인코딩이 서로 일치하지 않기 때문.

    서로 다른 약속 체계로 소통하려니 문제가 생김.



## 프로그램과 프로세스

### 운영체제

  ![ë¦¬ëì¤ ì´ìì²´ì ì ë¶í ê³¼ì ](https://images.weserv.nl/?url=ssl%3Aimages.weserv.nl%2F%3Furl%3Dstatic.codeflow.study%252F1522956625218_Screen-Shot-20180406-at-4.30.05-AM.png%26crop%3D962%2C499%2C7%2C28%26q%3D100%26errorredirect%3Dssl%253Acodeflow.study%252Fimage-not-found.png&w=640&h=640&q=100&errorredirect=ssl%3Acodeflow.study%2Fimage-not-found.png) 



- 부팅시 실행되는 하나의 (시스템)프로그램

- 주변기기들을 상호 연결하고 제어

- 응용프로그램이 사용할 수 있는 서비스 및 라이브러리를 제공

  - 컴퓨터의 메인보드에 접속된 하드웨어들을 상호 연결하고 제어함

  - 응용프로그램이 사용 할 수 있는 서비스/라이브러리들을 제공

  - 보조 기억장치 및 주변기기를 추상화한 파일시스템을 조작 할 수 있도록 응용프로그램에 API를 제공

  - 네트워킹을 추상화하여 응용프로그램에 API를 제공

  - 공통적인 GUI를 쉽게 만들 수 있게 추상화하여 응용프로그램에 API를 제공

    ★ ! 프로그램은 운영체제에 종속적이다.

  - 응용프로그램의 실행, 멀티태스킹을 위한 스케쥴링

  - 컴퓨터의 보안과 사용자 계정을 관리

- 응용프로그램의 실행

  - exploer.exe, Finder...

  - 멀티태스킹을 위한 스케줄링

    ★  프로그램은 운영체제에 종속적이다.




### API(Application Programming Interface)

- 응용 프로그램 프로그래밍 인터페이스. 응용 프로그램에서 사용할 수 있도록, 운영체제나 프로그래밍 

  언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스(사물간 또는 사물과 인간간의 의사소통이 가

  능하도록 일시적 혹은 영속적인 접근을 목적으로 만들어진 물리적, 가성적 매개체)

- 운영체제가 개발자들을 위해 미리 높은 추상화 수준으로 준비해놓은 코드의 집합.

> ???: 네가 프로그램을 만들 때 무슨무슨 기능을 쓸 수 있게 미리 코드(API)를 준비를 해뒀어! 
>
> 이러이러한 방식대로만 코드를 작성하면 되니까 설명서 잘 읽고 잘 써먹어!



### 프로그램

![ê¸°ê³ì´ìì ê³ ìì¤ ì¸ì´ê¹ì§](https://images.weserv.nl/?url=static.codeflow.study%2F1522956178388_languages.jpg&w=440&h=440&q=100&errorredirect=ssl%3Acodeflow.study%2Fimage-not-found.png)

![ì´ìë¸ë¦¬ì ê¸°ê³ì´(CPU ì¸ì¤í¸ë­ì ì¤í¸ë¦¼)](https://images.weserv.nl/?url=static.codeflow.study%2F1522956075190_ext2machinecode.png&w=640&h=640&q=100&errorredirect=ssl%3Acodeflow.study%2Fimage-not-found.png) 

  

- **기계어(명령어, Instruction)**

  - 0x000000FF는 더하기!
  - 0x000000FE는 빼기!

- **CPU 아키텍쳐(명령어 집합, Instruction Set):** 기계어와 하드웨어 기능을 Mapping한 것.

- **어셈블리어**

  - add(더하기)는 0x000000FF

  - sub(빼기)는 0x000000FE

- **프로그래밍 언어**

  - x+y 라는 프로그래밍 코드는 어셈블리어로 add x y 라고 표현 가능

  - 프로그래밍 언어로 작성된 소스코드는 **단순한 텍스트 파일**

  - 텍스트파일 => 어셈블리어 => 기계어의 번역을 통해 소스코드를 CPU가 실행가능한 포맷으로 만

    드는 과정을 컴파일이라 칭함. 번역해주는 프로그램은 **컴파일러.**

  - 번역된 파일을 **실행파일(프로그램)**이라고 함

  - 컴파일된 프로그램은 운영체제와 CPU아키텍쳐에 종속적.

- 리눅스에서 컴파일한 프로그램은 윈도우에서 실행되지 않는다.

- Intel CPU 아키텍쳐에 맞게 컴파일한 프로그램은 ARM 아키텍쳐 CPU를 쓰는 컴퓨터에서 실행되지 않거나 오작동을 함

- Intel CPU 윈도우에서 작성한 소스코드(텍스트파일)을 복사해서 ARM 윈도우에서 컴파일을 할 수 있을까? **문제 없음.**

- Intel 리눅스에서 작성한 소스코드를 복사해서 ARM 윈도우에서 컴파일이 될까? **될 수도, 안 될수도**

- 소스코드에서 리눅스 운영체제에 종속적인 기능을 사용한다면? (GUI, API 등) **사용 불가**

- POSIX

  - 이식 가능 운영체제 인터페이스의 약자.
  - 서로 다른 UNIX OS의 공통 API를 정리하여 이식성 높은 유닉스 응용 프로그램을 개발하기 위한 목적으로, IEEE가 책정한 애플리케이션 인터페이스 규격.
  - 유닉스 계열 외에 마이크로소프트 윈도 NT는 POSIX 1.0에 준하는 POSIX 서브 시탑재하고 있으며, POSIX 응용 프로그램을 서브 시스템에서 실행할 수 있다.

####  ※ 결론: 1. 상황에 따라 다르며, 플랫폼에 따라 차이가 날 수 있다.

####                 2. 프로그램은 CPU 아키텍쳐와 운영체제에 종속적이다.

###  





