---
layout: 기본
title: 기본CS정리
---

## 추상화

```
Application: AAABAABCAACC

---------------------------------------
layer A'': AAAB, AABC, AACC, ...
---------------------------------------
layer A': AA, AB, BC, CC, ...
---------------------------------------
layer A : A, B, C
---------------------------------------

```

추상화 : 중복을 없애고 복잡한 것을 단순하게 표현하는 것

핵심: '부품의 재사용', '계층의 분리/분업'



# 컴퓨터 구조와 파일

### 컴퓨터 구조

- CPU(Central Processing Unit) : 메모리(주기억장치)의 명령어(더하기, 빼기, 읽기, 쓰기)들을 읽어 순차적으로 

  처리. 이 때의 명령은 단순 산술 계산부터, 메모리나 주변 장치(보조기억장치, 프린터, 키보드, 디스플레이 등)

  와의 입출력(IO) 제어.
- CPU와 메모리 자체로도 하나의 컴퓨터라 칭할 수 있음.
- CPU: 계산 능력을 가진 사람
  메모리: 사람 앞의 책상(작업 공간)
  보조기억장치: 책(데이터)을 보관할 수 있는 책장(하드디스크)

- RAM(Random Accecc Memory): 휘발성(전원이 꺼지면 데이터 날아감) 메모리.
- ROM(Read Only Memory): BIOS 내용이 영구적으로 기록되어 있음



### CPU와 메모리

> CPU와 메모리는 대화한다! 프로세스(실행중인 프로그램)는 메모리 안에 존재함.

- 32bit vs 64bit

  - **32bit: 0000 0000 0000 0000 0000 0000 0000 0000**

  - CPU가 처리할 수 있는 명령어의 크기, CPU가 가리킬 수 있는 메모리의 번지수, 메모리 데이터 블록의 크

    기 등이 32bit로 고정되어 있음.

  - 메모리 번지수의 최대: 1111 1111 1111 1111 1111 1111 1111 1111 => 2^32 => 대략 43억

    0번지부터 대략 40억번지(0 ~ 4GB)까지 표현 가능.

    그러므로, 32bit CPU에서는 메모리(RAM) 용량이 4GB 이상을 인식할 수 없음.

  - **64bit: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000**

  - 2^64 bit => 약 1800경. 32bit와 비교했을 때 어마어마한 차이.



### 메모리와 보조기억장치

- 프로그램 최초 실행 중 Loading이 뜨는 이유: 보조기억장치에 저장된 프로그램(데이터)을 메모리로 읽어들이는(Load) 과정 중 소요되는 시간이 필요하기 때문.  
- 보조기억장치가 필요한 이유: RAM은 휘발성 -> 영구적 저장 불가. 비휘발성 저장장치 필요.



### 파일

- 메모리든 보조기억장치든 저장되어있는 모든 데이터는 1010101로 반복되어있는 단순한 이진 데이터이다. 

- 데이터를 구성하는 약속에 따라서 010101... 을 기록.
  - 숫자, 문자를 다루는 체계. 이러한 체계는 오래 전부터 이미 자리 잡혀 있음.

  - 소프트웨어별로 독립적으로 다루는 체계(ex. MSword는 .hwp 파일을 읽을 수 없음)

  - **파일명이나 확장자는 파일 자체를 구분하는 역할일 뿐, 이외의 역할은 없음.**

    운영체제에서 파일을 구분하고 인식하기 위한 확장자일 뿐.

    *.jpg 라고 해서 무조건 이미지 파일이라고 장담할 수 없음.

    다만, 실제 파일 내부의 데이터가 jpg의 약속 체계를 따르는지가 중요.

  - 파일에 기록된 이진 데이터가 의미를 가질 때는, 관련된 소프트웨어(프로그램)이 파일을 읽고 쓸 때이다.

    이 때, 파일의 의미를 가지려면, 이진 데이터를 특정한 약속(=파일 포맷)에 맞춰 나열해야 함.

  - 대표적인 파일 포맷: 문서, 프로그램, 영상, 사운드, 이미지, 압축 프로그램 등
- 실행파일

  - 다른 파일과 다른 특수한 파일인가? No. 실행파일 또한 101010... 으로 이루어진 단순한 파일.

  - 실행 파일(프로그램)을 실행하는 주체는 운영체제임. 운영체제에 종속된 파일 포맷을 따름.

    (윈도우에서 실행되는 실행파일은 맥에서 실행할 수 없음)



### 인코딩

- 문자를 표현하기 위한 약속

- 컴퓨터의 초창기때부터 정수와 소수 등 수의 체계를 표현하는 약속이 구현되어 있었음.

- ASCII

  - 컴퓨터와 통신 장비를 비롯한 문자를 사용하는 많은 장치에 사용. 

    대부분의 문자 인코딩이 아스키에 기초를 두고 있음.

  - 정수와 문자(숫자, 공백 및 특수문자)를 1:1로 Mapping(ex. 65=A, 66=B ...)
  - 0~127(7bit)까지 128가지의 문자열을 Mapping

- ANSI

  - ASCII 인코딩에서 남은 1byte를 활용해 128~255까지의 수를 다른 언어로 확장한 1Byte(8bit) 인코딩

    ANSI-949는 남은 128~255까지의 수를 한글에 Mapping한 인코딩

- Unicode

  - 전세계의 모든 문자를 일관적으로 표현할 수 있게 설계된 산업표준.
  - 전세계의 문자를 효율적으로 1:1 Mapping.

- UTF-8

  - 대부분의 웹에서 UTF-8을 씀

  - 전 세계의 문자를 1~4byte의 가변 길이로 표현.

  - ASCII와 호환 가능

  - 웹 및 다양한 산업에서의 대표주자

  - 특히 UTF-8에서 한글이 깨지는 경우는, 저장할 때(서버에서 전송해주는 웹페이지)와 인코딩을 읽을 때(브

    라우저에서 다운 받은 웹페이지를 해석할 때)의 인코딩이 서로 일치하지 않기 때문.

    서로 다른 약속 체계로 소통하려니 문제가 생김.



# 프로그램과 프로세스

### 운영체제

  ![ë¦¬ëì¤ ì´ìì²´ì ì ë¶í ê³¼ì ](https://images.weserv.nl/?url=ssl%3Aimages.weserv.nl%2F%3Furl%3Dstatic.codeflow.study%252F1522956625218_Screen-Shot-20180406-at-4.30.05-AM.png%26crop%3D962%2C499%2C7%2C28%26q%3D100%26errorredirect%3Dssl%253Acodeflow.study%252Fimage-not-found.png&w=640&h=640&q=100&errorredirect=ssl%3Acodeflow.study%2Fimage-not-found.png) 



- 부팅시 실행되는 하나의 (시스템)프로그램

- 주변기기들을 상호 연결하고 제어

- 응용프로그램이 사용할 수 있는 서비스 및 라이브러리를 제공

  - 컴퓨터의 메인보드에 접속된 하드웨어들을 상호 연결하고 제어함

  - 응용프로그램이 사용 할 수 있는 서비스/라이브러리들을 제공

  - 보조 기억장치 및 주변기기를 추상화한 파일시스템을 조작 할 수 있도록 응용프로그램에 API를 제공

  - 네트워킹을 추상화하여 응용프로그램에 API를 제공

  - 공통적인 GUI를 쉽게 만들 수 있게 추상화하여 응용프로그램에 API를 제공

  - 응용프로그램의 실행, 멀티태스킹을 위한 스케쥴링

  - 컴퓨터의 보안과 사용자 계정을 관리

- 응용프로그램의 실행

  - exploer.exe, Finder...

  - 멀티태스킹을 위한 스케줄링

    **★  프로그램은 운영체제에 종속적이다.**




### API(Application Programming Interface)

- 응용 프로그램 프로그래밍 인터페이스. 응용 프로그램에서 사용할 수 있도록, 운영체제나 프로그래밍 

  언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스(사물간 또는 사물과 인간간의 의사소통이 가

  능하도록 일시적 혹은 영속적인 접근을 목적으로 만들어진 물리적, 가성적 매개체)

- 운영체제가 개발자들을 위해 미리 높은 추상화 수준으로 준비해놓은 코드의 집합.

> " 네가 프로그램을 만들 때 무슨무슨 기능을 쓸 수 있게 미리 코드(API)를 준비를 해뒀어! 
>
> 이러이러한 방식대로만 코드를 작성하면 되니까 설명서 잘 읽고 잘 써먹어! "



### 프로그램

![ê¸°ê³ì´ìì ê³ ìì¤ ì¸ì´ê¹ì§](https://images.weserv.nl/?url=static.codeflow.study%2F1522956178388_languages.jpg&w=440&h=440&q=100&errorredirect=ssl%3Acodeflow.study%2Fimage-not-found.png)

![ì´ìë¸ë¦¬ì ê¸°ê³ì´(CPU ì¸ì¤í¸ë­ì ì¤í¸ë¦¼)](https://images.weserv.nl/?url=static.codeflow.study%2F1522956075190_ext2machinecode.png&w=640&h=640&q=100&errorredirect=ssl%3Acodeflow.study%2Fimage-not-found.png) 

  

- **기계어(명령어, Instruction)**

  - 0x000000FF는 더하기!
  - 0x000000FE는 빼기!

- **CPU 아키텍쳐(명령어 집합, Instruction Set):** 기계어와 하드웨어 기능을 Mapping한 것.

- **어셈블리어**

  - add(더하기)는 0x000000FF

  - sub(빼기)는 0x000000FE

- **프로그래밍 언어**

  - x+y 라는 프로그래밍 코드는 어셈블리어로 add x y 라고 표현 가능

  - 프로그래밍 언어로 작성된 소스코드는 **단순한 텍스트 파일**

  - 텍스트파일 => 어셈블리어 => 기계어의 번역을 통해 소스코드를 CPU가 실행가능한 포맷으로 만

    드는 과정을 컴파일이라 칭함. 번역해주는 프로그램은 **컴파일러.**

  - 번역된 파일을 **실행파일(프로그램)**이라고 함

  - 컴파일된 프로그램은 운영체제와 CPU아키텍쳐에 종속적.

  - 소스코드

    - 사람이 이해하기 쉬운 프로그래밍 언어로 프로그램의 작동을 묘사한 텍스트 파일

- 리눅스에서 컴파일한 프로그램은 윈도우에서 실행되지 않는다.

- Intel CPU 아키텍쳐에 맞게 컴파일한 프로그램은 ARM 아키텍쳐 CPU를 쓰는 컴퓨터에서 실행되지 않거나 오작동을 함

- Intel CPU 윈도우에서 작성한 소스코드(텍스트파일)을 복사해서 ARM 윈도우에서 컴파일을 할 수 있을까? **문제 없음.**

- Intel 리눅스에서 작성한 소스코드를 복사해서 ARM 윈도우에서 컴파일이 될까? **될 수도, 안 될수도**

- 소스코드에서 리눅스 운영체제에 종속적인 기능을 사용한다면? (GUI, API 등) **사용 불가**

- POSIX

  - 이식 가능 운영체제 인터페이스의 약자.
  - 서로 다른 UNIX OS의 공통 API를 정리하여 이식성 높은 유닉스 응용 프로그램을 개발하기 위한 목적으로, IEEE가 책정한 애플리케이션 인터페이스 규격.
  - 유닉스 계열 외에 마이크로소프트 윈도 NT는 POSIX 1.0에 준하는 POSIX 서브 시탑재하고 있으며, POSIX 응용 프로그램을 서브 시스템에서 실행할 수 있다.

- 결론

  - 상황에 따라 다르며, 플랫폼에 따라 차이가 날 수 있다.
  - 프로그램은 CPU 아키텍쳐와 운영체제에 종속적이다.
    

###  메모리 구조

* Text: 기계어로 표현된 프로그램의 로직들
* Data: 프로그램을 작성할 때 지정된 값들
* Heap: 런타임(Runtime)에 동적으로 생성되는 값들
* Stack: 함수라고 불리는 프로그램의 반복적인 로직이 실행되고 소멸되는 공간



# GUI/CLI, Shell, 파일 권한

- GUI(Graphical User Interface)
  - 웹브라우저, 에디엍, 게임, 대부분의 엔드유저용 응용프로그램, 스마트폰 앱 등
  - 응용프로그램들은 운영체제별로 비슷한 GUI를 가짐(OS가 제공하는 GUI API)
- GLI(Command Line Interface)
  - 명령 줄 인터페이스(CLI) 또는 명령어 인터페이스는 텍스트 터미널을 통해 사용자와 컴퓨터가 상호작용하는 방식
  - 작업 명령은 사용자가 컴퓨터 키보드 등을 통해 문자열의 형태로 입력하며, 컴퓨터로부터의 출력 역시 문자열의 형태로 주어진다
- 왜 CLI를 선호할까?
  - 개발자용 프로그램, 내부적인 시스템 프로그램 등은 대부분이 CLI 프로그램이다.
  - 가볍고 빠르며 텍스트만으로 입출력하기에 원격으로 조작하기 용이하다
  - CLI와 GUI의 차이는 단순한 User Interface의 차이일 뿐. 본질적으로는 큰 차이가 없는 프로그램들이다.
- Shell
  - 운영체제의 기능을 이용하고 **프로그램을 실행하기 위한 프로그램**
  - 운영체제의 Knernel(알맹이)과 유저를 이어주는 Shell(껍데기)
  - GUI Shell(explorer, 탐색기 등), CUI Shell(cmd, terminal)



### 개발자라면 왜 Linux를 사용해야 하는가?

- 튼튼하고 신뢰성 있는 무료 운영체제
- 다양한 플랫폼에 이식성
- 네트워킹에서 뛰어난 성능
- Opensource
- 거대한 생태계를 가지고 있음. 개발자들의 요람



# 네트워크

### 네트워크의 구분

- LAN(Local Area Network): 집, 회사, 지역 등의 지엽적인 네트워크를 지칭
- WAN(Wide Area Network): LAN보다 큰 규모로 국가, 대륙을 아우르는 원거리 망을 지칭
- 인트라넷(Intranet): 집, 회사 등 폐쇄적으로 운영되는 네트워크
- 인터넷(Internet): 전세계에서 접근이 가능한 공개적인 네트워크



### 통신의 원리

- 통신은 호스트 간에 이루어진다? 편지(데이터)를 건물(ip주소)간에 주고 받는다?

  정확히 말하자면, 

  **통신은 호스트(건물)의 프로세스(건물에 거주하는 사람)간 이루어진다!** 

  **(편지(데이터)는 사람(포트번호)간에 주고 받는다!)**

- 프로세스

  - 호스트상에서 프로세스를 구분하기 위한 표식 =>  **[포트 번호]**

- 호스트

  - 네트워크 안에서 호스트를 구분하기 위한 표식 =>  **[아이피 주소]**

- 네트워크 장치, 이더넷, 와이파이, 블루투스 등의 NIC(Network Interface Controller)

  - 네트워크 안에서 장치를 구분하기 위한 표식 =>  **[MAC 주소]**

```
Q. 맥주소를 두고 아이피가 필요한 이유는?
A. IP는 라우팅에 의해 적합하게 설계된 주소체계(지번 주소, 도로명 주소처럼)
   프로세스 → OS → 네트워크장치 → LAN/WAN → 라우터 → 라우터 → 라우터 ··· 
   → 어딘가의 호스트 → 어딘가의 프로세스
```



### 포트 번호(Port Number)

- 48bit(약 280조의 경우의 수) MAC Address → **장치 식별자**
  - 장치에 고정되어 있는 식별자
- 32bit/128bit의 IP Address → **호스트 식별자**
  - 운영체제에 할당되는 가상적인, 호스트를 식별하기 위한 식별자
- 16bit의 Port Number → **프로세스 식별자**
  - 2^16, 65536개 숫자
  - 이 중의 하나의 숫자를 운영체제로부터 할당
  - 0~1023 대역의 포트번호를 할당하려면 관리자 권한 필요
  - 예시) 
    클라이언트1 카카오톡 x.x.x:1234 --------------- 카카오톡 서버 a.b.c:3000
    클라이언트2 카카오톡 y.y.y:2111 --------------- 카카오톡 서버 a.b.c:3000
    클라이언트3 카카오톡 z.z.z:2333 ---------------- 카카오톡 웹서버 a.b.c:80
    클라이언트3 브라우저 z.z.z:2233 ---------------- 카카오톡 웹서버 a.b.c:80
- 각 다른 서버의 포트는 같을 수 없다.
- 서버측의 포트 번호는 고정이어야 클라이언트에서 연결을 할 수 있음.
  (보통 1024 아래의 낮은 대역으로 고정)
- 클라이언트측의 포트 번호는 (기본적으로) 랜덤.
  (보통 높은 대역의 포트 번호를 씀)

### IP(Internet Protocol)

- 32bit(2^32, 약 43억개)로 설계된 IP주소 체계
- 10101100 0001110 00000001 00000001
   → 172.30.1.1
- IP의 고갈 → 128bit의 IPv6로 호환성을 유지하면서 전환 중.



### 공인망과 사설망

- 기본적으로 공인 Public IP였으나 사설 Private IP 대역의 도입

- 10.0.0.0 ~ 10.255.255.255
  172.16.0.0 ~ 172.31.255.255
  192.168.0.0 ~ 192.168.255.255
  이 IP는 본인 마음대로 써도 된다. 사설망 안에서만.

- ex. 현재 사무실의 IP 목록

  - 172.30.1.1 스마트폰
  - 172.30.1.2 노트북
  - 172.30.1.3 데스크탑
  - 172.30.1.4 스마트TV
  - 172.30.1.254 공유기

  ​    → 사설망 IP가 5개

- NAT(Network Address Translation)

  - 네트워크 주소 변환
  - 사설IP와 공인IP를 Mapping시켜주는 기법

- 게이트웨이/공유기는 자신의 Public IP를 통해서 뒷단의 노드들을 대표해 인터넷에 연결



### OSI 7 Layer

![Frame/Packet Header](https://images.weserv.nl/?url=static.codeflow.study%2F1523025418664_net2.jpg&w=640&h=640&q=100&errorredirect=ssl%3Acodeflow.study%2Fimage-not-found.png) 

- Message
  - 프로세스가 전당하고자 하는 데이터
- Segment/Datagram
  - 보내는/받는 프로세스를 식별하기 위해 부가 데이터(Port) 추가
- Packet
  - 보내는/받는 호스트를 식별하기 위해 부가 데이터(IP)를 추가
- Frame
  - 실제로 데이터를 보내는/받는 장치인 유선랜(Ethernet) 카드, Wifi 및 Bluetooth카드 등의 장치를 식별하기 위해 부가 데이터(Mac Address) 추가



### TCP/UDP

- 송신자 MAC address, IP, Port

		수신자 MAC address, IP, Port

		데이터

- TCP
  - 신뢰성 프로토콜
  - 부가적인 데이터와 제어를 통해
    - 데이터의 수신 순서 보장
    - 데이터의 수신 성공 보장
    - 안전성과 신뢰성이 필요한 대부분의 응용프로그램, 메일, 메신저, 인터넷, 게임 등에 사용됨
- UDP
  - 데이터를 그냥 보냄. 비신뢰성 프로토콜
  - 데이터 누락, 중복, 순서 바뀜 등이 일어날 수 있음.
  - 게임, VoIP, IPTV, 영상 스트리밍 등



### 프로토콜(Protocol)

- 통신규약

- 저수준(Low-Level) 프로토콜

  - IP, TCP/UDP

- 응용 프로토콜

  - 원격으로 집안의 전등을 켜고 끄는 서버와, 스마트폰 클라리언트 앱의 통신규약을 만든다고 가정.

    1번 전등을 켠다 ==> 11 ==> 성공시 1

    1번 전등을 끈다 ==> 10 ==> 실패시 0

    2번 전등을 켠다 ==> 21

    2번 전등을 끈다 ==> 20

- Well Known Port

  - 오래 전부터 약속된 표준 프로토콜.
  - HTTP   80  웹 문서 전송
  - FTP      21  파일 전송
  - SSH     22  원격 셸
  - DNS     53  도메인 네임 서버
  - POP3, SMTP, HTTPS, etc ...



### 서비스 네트워킹 형태

- 서버/클라이언트
  - 서버는 다수의 클라이언트의 요청을 처리
  - 2개의 프로그램 필요
  - 클라이언트는 서버에 요청을 하고 응답을 받음
  - 온라인 게임, 웹 서비스, 페이스북 앱, 카카오톡 앱, 음악/영상 스트리밍, 원격 셸(SSH) 등
- P2P (Peer to Peer)
  - 각 클라이언트들이 서버이자 클라이언트의 역할을 담당
  - 한개의 프로그램이 필요
  - 토렌트, 1:1온라인 게임 등 서버/클라이언트 구분 없이 연결된 프로세스들이 동등한 작업을 함