## 프로세스란?

- 현재 실행중인 프로그램(=보조기억장치에 있는 명령어와 데이터의 집합)

- 하드웨어에 저장된 프로그램이 메모리(RAM)으로 적재된 후 CPU의 할당을 받으면 프로그램이 실행, 이를 프로

  세스라고 칭함.

- 멀티태스킹 환경에서 메모리에 프로그램이 여러개 적재되고 이때 CPU가 할당된 프로그램만 프로세스라고 부

  르지 않고, 대기중인 프로그램 또한 프로세스라고 부른다.

- 프로세스는 자원을 필요로 하고, 자원을 관리하는 것은 OS이다.

- 운영체제가 CPU를 할당하는 대상으로도 표현할 수 있음.

  - 프로세스에서 다른 프로세스로 CPU가 할당되는 것은 OS가 할 일.
  - 프로세스 하나가 실행되며 명령어를 처리하며 CPU가 할당되는 것은 사용자가 하는 일.

- 운영체제가 처리하는 시스템 내부에서의 작업 단위(=일의 단위)

- PCB에 존재하는 개체

- 최초의 프로세스를 제외하고 프로세스 안에서 System Call에 의한 루틴호출에 의해 생성

  이를 두고 프로세스의 부모-자식 관계라고 표현한다.

  생성한 프로세스를 부모, 생성된 프로세스를 자식이라 한다.



## PCB(Process Control Block)

- 프로세스 관리에 필요한 정보를 저장하기 위한 자료구조
- 프로세스가 생성되면 PCB를 추가 등록하고 프로세스가 종료되면 PCB에 저장된 정보 삭제
- 프로세스 상태가 변경되면 PCB에 저장된 정보 변경
- 리눅스의 경우 PCB는 구조체로 선언되어 있고, 내용은 수십가지 존재함
  - 프로세스 식별자
  - 프로세스 상태
  - 프로세스 스케줄링을 위한 우선순위
  - 프로세스가 적재된 메모리 주소공간
  - CPU 레지스터 값
  - 부모프로세스 식별자
  - 자식프로세서 식별자
  - CPU 사용기간
  - 사용 가능한 파일
  - 할당된 자원에 대한 포인터



## 프로세스 상태

1. 준비상태(Ready)
   - 프로세스 생성 후 CPU가 할당되기 전 상태
2. 실행상태
   - CPU가 할당된 상태. 실행중인 프로그램을 의미.
   - 프로세스가 정상적으로 실행을 완료하면 프로세스는 종료됨.
   - CPU 할당 시간 초과가 된 경우
     - 하나의 프로세스가 오랜 시간동안 CPU를 사용하지 못하도록 막고있어 일정 시간동안만 CPU를 사용할 수 있도록 제한한다. CPU 할당시간이 초과된 경우 준비(READY)상태로 돌아간다.
   - 자신이 요청한 사건이 완료됐을 경우
     - 어떠한 사건을 요청하면 CPU는 다른 메모리의 주소에 할당되게 되고 사건을 요청한 프로세스는 대기상태로 들어가게됨
     - 요청한 작업이 끝나면 다시 준비상태로 돌아가고 CPU할당을 기다리게 됨.
     - 프로세스의 상태가 PCB에 입력됨
3. 대기상태(Wait)
   - 프로세스가 CPU를 할당받아 실행되다가 어떤 사건이 발생할때까지 멈추어있는 상태
   - 대기상태에 있던 프로세스가 기다리던 어떤 사건의 발생으로 인해 나머지부분의 실행을 위해 준비(Ready)상태로 전이되는 과정



## 프로세스 메모리 구조

1. Code(Text) 영역

   - 코드 자체를 구성하는 메모리 영역. Hex, Bin파일 메모리
   - 프로그램 명령이 위치하는 곳으로, 기계어로 제어되는 메모리 영역

2. Data 영역

   - 전역변수, 정적변수, 배열, 구조체 등이 저장
   - 프로그램이 실행될 때 생성되고 종료되면 시스템에 반환됨
   - 함수 내부에 선언된 Static 변수는 실행될 때 공간만 할당되고, 그 함수가 실행될 때 초기화된다.

3. Stack 영역

   - 프로그램이 실행되어 일시적으로 저장할 데이터를 담아두는 공간

     (프로그램은 실행되는 것이 아니기 때문에 스택이 필요하지 않다.)

   - 스택에 저장되는 데이터는 루틴들을 처리하며 되돌아갈 주소를 저장함. 

     선입후출(LIFO) 방식.

   - 데이터영역에 일시적으로 사용할 지역변수를 저장하는 것보다는 스택영역에 지역변수를 
     저장하는 것이 더욱 효율적이다.

4. Heap 영역

   - 프로그램이 자동으로 사용하는 임시 메모리 영역
   - 지역변수, 매개변수, 리턴값 등 잠시 사용되었다가 사라지는 데이터를 저장하는 영역
   - 함수 호출시 생성되고, 함수가 끝나면 시스템에 반환



## 문맥교환(Context Switch)

> 하나의 프로세스가 CPU를 사용중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해, 이전의 프로세스의 상태를 PCB에 보관하고 새로운 프로세스의 상태를 적재하는 작업

- 인터럽트 핸들러에 의해 인터럽트 처리 루틴이 시작됨
- 인터럽트 처리과정 중 문맥교환 발생
- 문맥교환이 일어나는 동안 일반적으로 Running 상태에서 Ready 상태로 갔다가 다시 Running 상태가 된다.



## 프로세스 스케줄링

> 준비큐에 등록된 여러개의 프로세스들 중, 스케줄링 전책에 따라 하나의 프로세스를 선정하고 선정된 프로세스에세 CPU를 할당하는 것

- CPU 사용에 대한 프로세스들 중 하나의 프로세스를 선정하여 CPU 할당

  즉, OS는 프로세스를 선정하고 CPU를 할당한다.

- 프로세스를 선정하는 것을 "정책"

  CPU 할당하는 것을 "디스패치" 라고 함

- 프로세스 준비 상태에 있는 프로세스를 저장하는 자료구조를 준비큐 라고 함.



## 스케줄링 정책

### 선점 기법

- 한 프로세스가 CPU를 할당받아 실행중이라도 다른 프로세스가 현재 프로세스를 중지시키고 CPU를 강제적으로 뺏을 수 있는 스케줄링 방식.
- 빠른 응답을 요구하는 시분할 시스템에서 주로 채택
- 장점
  - 긴급하게 처리해야할 높은 우선순위를 가진 프로세스들을 빠르게 처리 가능
- 단점
  - 프로세스간 문맥교환 자주 발생 → 오버헤드 증가
  - 효과적인 선점을 하기 위해 준비 상태의 프로세스가 많아야 함
  - 우선순위 고려해야 함

1. ##### RR(Round Robin)

   - FCFS(First Come First Served) + 선접방식.

   - FCFS 기법과 같이 준비상태 큐에 먼저 들어온 프로세스가 먼저 CPU를 할당받음

     시간을 할당해서 할당시간 종료 후 완료하지 못하면 폐기

   - 우선순위의 형평성을 위해 타임 슬라이스 or 시간 할당량에 의해 시간 제한 받음

     - 시간 할당량이 클 경우: FIFO 스케줄링 방법과 차이가 없음
     - 시간 할당량이 작을 경우: 문맥교환 오버헤드가 상대적으로 ↑

2. ##### SRT (Shortest Remaining Time)

   - SJF(Shortest Job First) + 선점방식
   - 준비상태 큐에 새로 도착한 프로세스의 실행 시간과 현재 실행중인 프로세스의 남은 시간을 비교, 수행 시간이 적은 프로세스에 CPU를 할당하는 기법

3. ##### 다단계 큐(Multi Level Queue)

   - 프로세스를 특정 그룹으로 분류할 수 있을 경우, 그룹에 따라 각기 다른 준비상태 큐를 사용. 큐 사이에 우선순위를 부여하는 기법

4. ##### 다단계 피드백 큐(Multi Level Feedback Queue)

   - 특정 준비상태 큐에 들어간 프로세스가 다른 준비상태 큐로 이동할 수 없는 다단계 큐 기법을 준비상태 큐 사이를 이동할 수 있도록 개선한 방법
   - 다양한 특성의 작업이 혼합된 경우 유용

   

### 비선점 기법

- 한 프로세스가 CPU를 할당받아 실행중이라면 다른 프로세스들이 CPU를 강제적으로 뺏을 수 없는 스케줄링 방식.
- 일괄 처리 시스템에 적합
- 장점
  - 모든 프로세스에 대한 공정한 처리 가능
  - 프로세스간 오버헤드가 적어 효율적
- 단점
  - 긴 작업이 짧은 작업을 오랫동안 기다리게 되는 경우 발생

1. ##### FIFO(First In First Out) = FCFS(First Come First Served)

   - 준비 큐에 처음 오는 프로세스를 맨 처음에 실행

     생성된 순서가 아니라, 준비큐에 등록된 순서대로 실행된다.

     (꼭 프로세스가 생성된 순서대로 준비큐에 등록된다고 할 수는 없다.)

   - 응답시간 차가 적어 예측이 쉬움

   - 구현은 가장 쉬우나, 효율성이 많이 떨어짐

   - CPU 사용이 긴 프로세스에 의해 짧은 프로세스들이 오래 기다리는 '호송 효과(convoy effect)'에 의해 평균 대기시간이 길어짐(ex. 은행)

2. ##### SJF(Shortest Job Frist)

   - 최신작업선 처리

   - 대기중인 작업중 수행시간이 가장 적은 프로세스에 CPU를 할당하는 기법

   - 평균 대기시간 최소화

     각 프로세스의 CPU 요구시간 알기 어려움

3. ##### HRN(Highest Response Ratio Next)

   - SJF 기법의 약점인 '긴 작업과 짧은 작업의 지나친 불평등'을 보완한 기법
   - 응답률 = (대기시간 + 실행시간) / 실행시간

4. ##### 우선순위(Priority)

   - 준비상태 큐에서 대기중인 각 프로세스마다 우선순위 부여

     우선순위가 가장 높은 프로세스에 먼저 CPU 할당

     우선순위가 같을 경우, FIFO 또는 SJF 도입

5. ##### 기한부(Deadline)

   - 프로세스에게 일정한 시간을 주고 그 시간안에 완료하도록 하는 기법