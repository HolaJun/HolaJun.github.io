## 운영체제의 정의

> 컴퓨터 시스템이 보유하고 있는 자원들을 효율적으로 관리하고 사용자에게 편의성을 제공하기 위하여 CPU 관리, 메모리 관리, 파일 관리, 입출력 장치 관리, 사용자 인터페이스를 담당하는 루틴들이 유기적으로 결합된 프로그램

#### 사용자 관점

- 컴퓨터 시스템을 보다 편리하게 사용할 수 있는 환경을 제공해 줄 수 있는 프로그램

#### 시스템 관리자 관점

- 컴퓨터 시스템의 자원들을 효율적으로 이용할 수 있도록 제어하는 프로그램

#### 시스템

- 어떤 주어진 목적을 달성하기 위하여 여러개의 구성요소들이 유기적으로 결합된 집합체



## 운영체제의 목적 및 필요성

- 컴퓨터 시스템 자원의 효율적 관리와 사용자의 편의성 제공
- 자원의 이용률과 사용자 편의성 극대화
- 사용자의 불편함을 덜어주고 컴퓨터 시스템 자원의 이용률을 향상시키기 위한 프로그램, 
  즉 운영체제의 개발이 요구되어옴.



## 운영체제 구성 요소 및 기능

1. ##### CPU 관리

   - 프로그램 실행 및 종료, 프로그램들간의 CPU 공유 등의 기능

2. ##### 메모리 관리

   - 메모리의 사용 영역과 빈 영역을 유지 및 관리하여 새로운 영역의 요구와 사용 영역의 반납 등의 기능

3. ##### 파일 관리

   - 사용자가 입력한 프로그램이나 데이터를 파일형태로 보조기억장치에 저장하고 사용자의 요청에 따라 해당 파일을 보조기억장치로부터 읽어들이는 등의 기능

4. ##### 입출력 장치 관리

   - 실행중인 프로그램에서 필요로 하는 입출력 장치들을 사용할 수 있도록 관리하는 기능 제공

5. ##### 네트워킹

   - 서로 다르 컴퓨터 시스템간의 통신을 위한 네트워킹 기능

6. 보호

   - 효율적인 자원관리 위해 공유하는 자원에 대한 보호기능

7. 오류 처리 및복구

   - 컴퓨터 시스템의 오류 탐지하며, 이를 복구하거나 사용자에게 경고하는 기능 제공



## 컴퓨터 시스템의 동작원리

- 입력장치를 통해 CPU 명령어들을 메모리에 적재시킨 후, CPU로 하여금 그 명령어들을 하나씩 처리하여 출력장치로 그 결과를 출력하도록 PC(Program Counter) 레지스터 값 조작.
- 응용프로그램을 실행시키기 위해 마우스를 통해 해당 아이콘을 더블클릭한 경우
  1. 마우스의 더블클릭 인터럽트 처리(인터럽트 처리)
  2. 더블클릭된 아이콘에 해당하는 응용프로그램의 파일을 보조기억장치에서 찾음
     (파일 시스템)
  3. 응용프로그램을 적재하기 위한 메모리의 빈 공간을 찾음(메모리 관리)
  4. 보조기억장치로부터 응용프로그램을 메모리로 적재(입출력 장치관리)
  5. CS:EIP값 조작(CPU 관리)



## 운영체제 진입점(Entry Point)

- PC 레지스터 값이 사용자 프로그램이 적재된 메모리 줏에서 운영체제가 적재된 메모리 주소로 변경되어야 함

- 프로그램 상태 레지스터(PSW: Program Status Word)

  - 프로그램의 실행 상태 구별

- 시스템 호출(System Call)

  - 응용프로그램과 운영체제 사이의 인터페이스 수단
  - 응용프로그램 내부의 서비스 루틴 호출
  - API(Applicaition Programming Interface)라고 불리는데 이는 시스템 호출을 통하여 운영체제 서비스를 이용한다

- 인터럽트(Interrupt)

  - 입출력 장치에서 CPU로 보내는 신호. CPU와 입출력 장치 사이의 인터페이스 수단
  - 일반적으로 인터럽트가발생하면 CPU는 실행하던 프로그램을 잠시 중단하고 상태 레지스터와 PC(Program Counter)등을 스택에 잠시 저장한 후 인터럽트 서비스 루틴으로 이동한다.
    인터럽트 서비스 루틴이 끝난 후 다시 원래의 작업으로 돌아온다.

  > 플링(Polling) 방식과의 차이
  >
  > - 폴링은 사용자가 명령어를 사용하여 입력 핀의 값을 계속 읽어 변화를 알아내는 방식이다. 
  > - 사용자 프로그램에서 이벤트가 발생할 경우 운영체제로 진입해 이벤트가 발생할 때까지 계속 기다린다.
  > - 인터럽트는 MCU 자체가 하드웨어적으로 그 변화를 체크하여 변화시에만 일정 동작을 하는 방식

- 예외현상

  - 프로그램이 실행되는 중에 CPU 내부에서 발생하는 시스템 오류

    예를 들면 나누기 명령어를 처리하는 과정에서 "0으로 나누기"를 수행하는 경우 예외가 발생.

  - 일반적으로 예외현상 처리 루틴은 운영체제 내부에 구현되고, 사용자 모드에서 프로그램이 실행되는 동안 예외현상이 발생하면 예외현상 처리 루틴을 실행하기 위해 운영체제로 진입한다



## 자원관리

> 프로세스의 자원을 공유한다 = 자원을 효율적으로 관리한다

- 자원을 효율적으로 관리하기 위해 자원을 공유하게 되면 서로간에 상호 영향을 미쳐서 결정성을 보장하지 못하게 된다.

  결정성 보장을 못한다는 것은 항상 결과가 고르지 않다는 것이다. 예를 들어 1~10의 합의 결과가 항상 다름.

- 운영체제의 자원을 효율적으로 관리하기 위해 자원을 공유하고, 이로인해 서로 상호영향을 가함으로써 결정성을 보장하지 못한다 



## 교착상태(Deadlock)

> 프로세스들이 서로 작업을 진행하지 못하고 영원히 대기 상태로 빠지는 현상.

- 프로세스 사이에 할당된 자원의 충도롤 인해 발생
- ex) A, B 프로세스는 각각 a와 b라는 자원을 할당받아 사용하고 있다. A에서는 작업을 계속 하기 위해 자원 b를 요청하고, B프로세스는 자원 a를 요청하게 되면 각각의 프로세스가 요청한 자원이 이미 다른 프로세스에 할당되어 있기 때문에 할당이 풀릴 때까지 대기상태에 들어가게 된다. A, B 프로세스는 모두 상대방이 자원을 내놓기를 기다리면서 대기 상태로 돌아가기 때문에 영원히 대기상테에 머무는 교착상태에 빠지게 된다.



## 세마포어(Semaphore)

> 공유된 자원에 여러개의 프로세스가 동시에 접근하면서 문제가 발생하는 것으로, 공유된 자원 속 하나의 데이터는 한 번에 하나의 프로세스만 접근할 수 있도록 고안한 기법.

- P(wait), V(signal) 연산

- P연산

  ```c
  procedure P(S) // 최초의 S값은 1
  
  while S=0 do wait // S가 0이면 1이 될때까지 Wait
  
  S := S-1 // S를 0으로 만들어 다른 프로세스가 들어오지 못하도록 함
  
  end P
  ```

- V 연산

  ```c
  procedure V(S) // 현재 상태 S값 0
  
  S := S+1 // S를 1로 원위치시켜 해제하는 과정
  
  end V // 이제는 다른 프로세스가 들어올 수 있음.
  ```

- 한 프로세스가 P나 V를 수행하고 있는 동안에는 프로세스가 인터럽트를 당하지 않음. P&V 연산을 통해 임계영역에 대한 상호배제를 구현할 수 있음

- P(S);

  ―――――――――――――――――――

  Critical Section(임계영역)

  ―――――――――――――――――――

  V(S);

- 최초의 S값은 1이고 위와 같은 위험지역을 포함하는 프로세스 A와 B가 있다고 할 때, 위와 같이 세마포어를 사용하면 P(S)를 먼저 수행하는 프로세스가 S를 0으로 해놓고 위험지역에 들어가므로 나중에 도착하는 프로세스는 P에서 더이상 진행되지 못하고 기다리게 된다. 먼저 들어갔던 프로세스가 V(S)를 해주어야 비로소 P(S)에서 기다리던 프로세스가 위험지역에 들어갈 수 있고 따라서 상호배제가 실현된다.   

- 예제

  ```c
  wait(S) {
  	while(S <= 0); // no-operation
  	S--;
  }
  signal(S) {
      S++;
  }
  ```



## 뮤텍스(Mutex)

> Critical Section(임계영역)을 가진 쓰레드들의 Running Time이 서로 겹치지 않게 각각 단독으로 실행되게 하는 기술

- 다중 프로세스들의 공유 리소스에 대한 접근을 조율하기 위해 locking과 unlocking을 사용한다.
  즉, 뮤텍스 객체를 두 쓰레드가 동시에 사용할 수 없음.



## 세마포어와 뮤텍스의 차이점

- 세마포어는 뮤텍스가 될 수 있지만, 뮤텍스는 세마포어가 될 수 없음.
- 세마포어는 소유할 수 없지만, 뮤텍스는 소유가 가능하며 소유주가 이에 대한 책임을 진다.
- 뮤텍스의 경유 뮤텍스를 소유하고 있는 쓰레드가 이 뮤텍스를 해제할 수 있다. 하지만 세마포어의 경우 이러한 세마포어를 소유하지 않는 쓰레드가 세마포어를 해제할 수 있음.
- 세마포어는 시스템 범위에 걸쳐있고 파일시스템상의 파일 형태로 존재. 반면 뮤텍스는 프로세스 범위를 가지며 프로세스가 종료될 때 자동으로 Clean up 됨.
- 가장 큰 차이점은 관리하는 동기화 대상의 갯수인데, 뮤텍스는 동기화 대상이 오직 하나뿐일때, 세마포어는 동기화 대상이 하나 이상일 때 사용